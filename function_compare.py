import os
import argparse
import sys

def get_functions(filename):
    """
    Read strings from files generated by an IDAPython script and store them in a list for further processing.
    """
    list_functions= []
    with open(filename,'rU') as f:
        list_functions= [line[:-1] for line in f.readlines()]

    return list_functions

def get_exe_to_reverse():
    """
    Read command line arguments.
    """
    parser= argparse.ArgumentParser()
    parser.add_argument('file', nargs=1, help='Enter the name of the file you want to reverse engineer here')
    args = parser.parse_args()

    return args.file[0]

def function_compare(exe_to_reverse, file_string_map):
    """
    Compare each function from the binary you want to reverse with all the functions from all other files
    If there's a match store the name of the DLL and the function that was matched in a dictionary
    Return the dictionary for further analysis
    """
    l1= file_string_map[exe_to_reverse].split('^')
    match_result= {}

    for key,value in file_string_map.iteritems():
        if key != exe_to_reverse:
            l2= value.split('^')
            for i in l1:
                t1= i.split(':')
                for j in l2:
                    t2= j.split(':')
                    if t1[1] == t2[1]:
                        match_result[t2[0]]= key
                        break
        else:
            continue

    return match_result

if __name__ == "__main__":
    exe_to_reverse= get_exe_to_reverse()

    output_dir= 'all_outputs'
    file_string_map={}
    for filename in os.listdir(output_dir):
        list_functions= get_functions(output_dir+'/'+filename)
        file_string_map[filename[:-4]]='^'.join(list_functions)

    match_result= function_compare(exe_to_reverse, file_string_map)
    for key,value in match_result.iteritems():
        print key,'-',value
